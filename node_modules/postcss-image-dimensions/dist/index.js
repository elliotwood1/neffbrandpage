'use strict';

var pluginName = 'postcss-image-dimensions';
var fs = require('fs');
var globby = require('globby');
var jimp = require('jimp');
var isImage = require('is-image');
var roundPrecision = require('round-precision');

var _require = require('postcss'),
    plugin = _require.plugin;

var LocalStorage = require('node-localstorage').LocalStorage;

var cachePath = './.cache';
var cache = null;
var globPattern = './src/images/**/*';
var methodMap = {
	'image-width': {
		pattern: /image-width\(['"]?(.+?)['"]?\)/,
		propertyName: 'width1x',
		suffix: 'px'
	},
	'image-width-2x': {
		pattern: /image-width-2x\(['"]?(.+?)['"]?\)/,
		propertyName: 'width2x',
		suffix: 'px'
	},
	'image-width-ratio': {
		pattern: /image-width-ratio\(['"]?(.+?)['"]?\)/,
		propertyName: 'widthRatio1x',
		suffix: '%'
	},
	'image-width-ratio-2x': {
		pattern: /image-width-ratio-2x\(['"]?(.+?)['"]?\)/,
		propertyName: 'widthRatio2x',
		suffix: '%'
	},
	'image-height': {
		pattern: /image-height\(['"]?(.+?)['"]?\)/,
		propertyName: 'height1x',
		suffix: 'px'
	},
	'image-height-2x': {
		pattern: /image-height-2x\(['"]?(.+?)['"]?\)/,
		propertyName: 'height2x',
		suffix: 'px'
	},
	'image-height-ratio': {
		pattern: /image-height-ratio\(['"]?(.+?)['"]?\)/,
		propertyName: 'heightRatio1x',
		suffix: '%'
	},
	'image-height-ratio-2x': {
		pattern: /image-height-ratio-2x\(['"]?(.+?)['"]?\)/,
		propertyName: 'heightRatio2x',
		suffix: '%'
	},
	'image-color': {
		pattern: /image-color\(['"]?(.+?)['"]?\)/,
		propertyName: 'color'
	}
};

function rgbToHex(_ref) {
	var r = _ref.r,
	    g = _ref.g,
	    b = _ref.b;

	function convert(c) {
		var hex = c.toString(16);
		return hex.length === 1 ? '0' + hex : hex;
	}
	return '#' + convert(r) + convert(g) + convert(b);
}

async function buildImageData(filePath) {

	var absolutePath = filePath;
	if (filePath.startsWith('./')) {
		absolutePath = filePath.substr(2);
	}

	var fileStat = await fs.statSync(filePath);
	var imageData = { path: absolutePath };

	// Retreive data from cache if exists
	var cacheKey = absolutePath.replace('.', '') + '.json';
	var cacheFilePath = cachePath + '/' + encodeURIComponent(absolutePath.replace('.', '')) + '.json';
	var imageDataCache = (await fs.existsSync(cacheFilePath)) ? cache.getItem(cacheKey) : null;
	var imageDataCacheMTime = imageDataCache ? await fs.statSync(cacheFilePath).mtime : null;

	return new Promise(function (resolve, reject) {

		if (imageDataCache && Date.parse(imageDataCacheMTime) > Date.parse(fileStat.mtime)) {
			return resolve(JSON.parse(imageDataCache));
		}

		return jimp.read(filePath).then(async function (img) {
			var _img$bitmap = img.bitmap,
			    width = _img$bitmap.width,
			    height = _img$bitmap.height;

			/**
    * Set the non-retina dimensions by halfing dimensions
    * and round up to nearest pixel. This seems to be the
    * approach of Photoshop and Jimp, so we'll go with that!
    */

			var width1x = Math.ceil(width / 2);
			var height1x = Math.ceil(height / 2);

			/**
    * Get the "average color" of the image by resizing down
    * to a 1 x 1px and getting the color of that pixel.
    *
    * TODO: Make this more accurate.
    */
			var rgb = img.resize(1, 1, jimp.RESIZE_BICUBIC).getPixelColor(0, 0);
			var color = rgb ? rgbToHex(jimp.intToRGBA(rgb)) : 'transparent';

			imageData.width1x = width1x;
			imageData.height1x = height1x;
			imageData.width2x = width;
			imageData.height2x = height;
			imageData.widthRatio1x = roundPrecision(width1x / height1x * 100, 4);
			imageData.widthRatio2x = roundPrecision(width / height * 100, 4);
			imageData.heightRatio1x = roundPrecision(height1x / width1x * 100, 4);
			imageData.heightRatio2x = roundPrecision(height / width * 100, 4);
			imageData.color = color;

			// Cache the image data
			cache.setItem(cacheKey, JSON.stringify(imageData));

			return resolve(imageData);
		});
	});
}

module.exports = plugin(pluginName, function () {
	var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


	// Override any default configs
	globPattern = options.globPattern || globPattern;
	cachePath = options.cachePath || cachePath;
	cache = new LocalStorage(cachePath);

	return async function (css) {

		var allImageData = await globby(globPattern).then(async function (files) {

			var imageFiles = files.filter(function (filePath) {
				return isImage(filePath);
			});

			return await Promise.all(imageFiles.map(buildImageData)).then(function (imageData) {
				return imageData.reduce(function (acc, currentImage) {

					// Use the image path as a unique ID of the image
					var imgPath = currentImage.path;

					delete currentImage.path;
					acc[imgPath] = currentImage;

					return acc;
				}, {});
			});
		});

		Object.keys(methodMap).forEach(function (method) {

			var helperConfig = methodMap[method];

			// http://api.postcss.org/Root.html#replaceValues
			css.replaceValues(helperConfig.pattern, { fast: method }, function (string) {
				var imagePath = string.match(helperConfig.pattern)[1];
				var imageData = allImageData[imagePath];

				try {
					if (imageData) {
						if (helperConfig.suffix) {
							return imageData[helperConfig.propertyName] + helperConfig.suffix;
						}
						return imageData[helperConfig.propertyName];
					}
					return string;
				} catch (error) {
					throw css.error(error.message, { plugin: pluginName });
				}
			});
		});
	};
});